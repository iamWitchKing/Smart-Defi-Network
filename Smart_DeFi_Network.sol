/**
 *Submitted for verification at BscScan.com on 2025-08-17
*/

// SPDX-License-Identifier: MIT
pragma solidity >=0.4.22 <0.9.0;
abstract contract Context {
    function _msgSender() internal view virtual returns (address) {return msg.sender;}
    function _msgData() internal pure virtual returns (bytes calldata) {return msg.data;}}
// Address Library (from OpenZeppelin Contracts v4.9.2). Utility functions related to the address type, including contract detection and safe calls. Source: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.9.2/contracts/utils/Address.sol
library Address {
    function isContract(address account) internal view returns (bool) { uint256 size; assembly {size := extcodesize(account)} return size > 0;}
    function sendValue(address payable recipient, uint256 amount) internal {require(address(this).balance >= amount, "Address: insufficient balance" ); (bool success, ) = recipient.call{value: amount}(""); require(success, "Address: unable to send value, recipient may have reverted" );}
    function functionCall(address target, bytes memory data) internal returns (bytes memory) { return functionCall(target, data, "Address: low-level call failed");}
    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {return _functionCallWithValue(target, data, 0, errorMessage);}
    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) { return functionCallWithValue(target, data, value, "Address: low-level call with value failed");}
    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) { require( address(this).balance >= value, "Address: insufficient balance for call"); return _functionCallWithValue(target, data, value, errorMessage);}
    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {require(isContract(target), "Address: call to non-contract"); (bool success, bytes memory returndata) = target.call{value: weiValue}( data); if (success) {return returndata; } else { if (returndata.length > 0) { assembly {let returndata_size := mload(returndata) revert(add(32, returndata), returndata_size)}} else { revert(errorMessage);}}}}
// Interface based on OpenZeppelin Contracts v4.9.2 - IERC20. Source: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.9.2/contracts/token/ERC20/IERC20.sol
interface IERC20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value);}
// SafeERC20 Library (from OpenZeppelin Contracts v4.9.2). Provides wrappers around ERC20 operations that throw on failure (when the token contract returns false). Source: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.9.2/contracts/token/ERC20/utils/SafeERC20.sol
library SafeERC20 {using Address for address;
    function safeTransfer(IERC20 token, address to, uint256 value) internal {_callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));}
    function safeTransferFrom( IERC20 token, address from, address to, uint256 value) internal {_callOptionalReturn( token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));}
    function safeApprove( IERC20 token, address spender, uint256 value) internal {require((value == 0) || (token.allowance(address(this), spender) == 0), "SafeERC20: approve from non-zero to non-zero allowance"); _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));}
    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {uint256 newAllowance = token.allowance(address(this), spender) + (value); _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance ));}
    function safeDecreaseAllowance( IERC20 token, address spender, uint256 value) internal { uint256 newAllowance = token.allowance(address(this), spender) - (value);_callOptionalReturn( token, abi.encodeWithSelector( token.approve.selector, spender, newAllowance));}
    function _callOptionalReturn(IERC20 token, bytes memory data) private {bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed"); if (returndata.length > 0) {require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");}}}
contract Smart_DeFi_NetWork is Context{using SafeERC20 for IERC20; struct Node { uint64 id; uint32 AL; uint32 AR; uint32 LT; uint32 RT; uint8 XI; bool YY; address UP; address PO; address QO;} mapping(address => Node) internal KW; mapping(address => uint8) internal EE; mapping(uint64 => address) internal VV; mapping(uint64 => uint32) internal QF; mapping(uint64 => uint32) internal ChCr; mapping(uint256 => address) internal JJ; mapping(uint256 => uint256) internal VPL; mapping(uint32 => address) internal JL; mapping(uint32 => address) internal VrL; mapping(address => bool) internal MaxPoint; mapping(address => bool) internal Agreement_; address internal Founder; address internal JY; address internal smart_Bank; address internal smart_Gift; address internal Founder_Wallet; address internal Agent;  address internal Smart_Import; IERC20 internal stableCoin; uint64 internal JK; uint24 internal DJ; uint32 internal ZL; uint32 internal voteTotal; uint32 internal VCr; uint256 internal time; uint256 internal RCr; uint256 internal ZM; uint256 internal DZ; uint256 internal LZ; uint256 internal rewardFee; uint256 internal newMember; bool internal Waiting; bool internal Set_Bank; bool internal Set_Gift; bool internal smart_Import; bool internal changeSwitch; string internal Road_Map; string internal Founder_Message;
    constructor(){ Founder = _msgSender(); stableCoin = IERC20(0x55d398326f99059fF775485246999027B3197955); smart_Bank = 0x07418EC67B00D0B3f7a69f0984BB145FC29c85e0; Founder_Wallet = 0x00e21f2B131CD5ba0c2e5594B1a7302A6Aa64152; smart_Gift = 0xdd4d21f89914fB23d169b982fEab23FeA666f3c8; Agent = 0xdd4d21f89914fB23d169b982fEab23FeA666f3c8; time = block.timestamp;}
    function BeCome_Owner(address Up) external {DC(Up);} function DC(address Up) private { require(I_C(_msgSender()) == false, "Just Wallet"); require(Up != address(0), "Dont Enter address 0"); require(KW[Up].XI != 2, " Upline Has 2 Directs "); require(_msgSender() != Up, " Dont Enter Your Address " ); require(!DX(_msgSender()), " You Are An Owner "); require(DX(Up), " Upline Not Exist "); require(Agreement_[_msgSender()] == true, " Write Agreement"); require(Owner_Is_My_Line( Founder_Wallet , Up) == true, "UpLines Are Not Imported"); require(Waiting == false, " Processing "); Waiting = true; stableCoin.safeTransferFrom(_msgSender(), address(this), 100 * 10**18); IERC20(stableCoin).transfer(smart_Gift, 5 * 10**18); VV[JK] = _msgSender(); JK++; Node memory owner = Node({ id: JK, AL: 0, AR: 0, LT: 0, RT: 0, XI: 0 , YY: KW[Up].XI == 0 ? false : true, UP: Up, PO: address(0), QO: address(0)}); KW[_msgSender()] = owner; JJ[newMember] = _msgSender(); DZ++;newMember++; if (KW[Up].XI == 0) {KW[Up].LT++; KW[Up].AL++; KW[Up].PO = _msgSender();} else {KW[Up].RT++; KW[Up].AR++; KW[Up].QO = _msgSender();} KW[Up].XI++; Waiting = false;}
    function Reward() external {DH();} function DH() private { require(I_C(_msgSender()) == false, "Just Wallet"); require(Owner_All_Point(_msgSender()) > 0, "Just NetWorker"); require(block.timestamp > time + 1 hours, " Reward Time Has Not Come "); ZB(); require(ZI() > 0, " Total Point Is 0 "); require(Waiting == false, " Processing "); Waiting = true ; ZL = ZI(); JY = _msgSender(); uint256 ZO = ZK(); ZM = ZO; RCr++; VPL[RCr] = ZO; uint256 D_T = ((DZ * rewardFee * 10**18) / 2 ); for (uint24 i = 0; i < DJ; i++) { Node memory ZN = KW[JL[i]]; uint32 UT = ZH(JL[i]); if (ZN.LT == UT) {ZN.LT = 0; ZN.RT -= UT;} else if (ZN.RT == UT) {ZN.LT -= UT; ZN.RT = 0;} else { if (ZN.LT < ZN.RT) {ZN.RT -= ZN.LT; ZN.LT = 0;} else {ZN.LT -= ZN.RT; ZN.RT = 0;}} KW[JL[i]] = ZN; if (Owner_All_Point(JL[i]) < 100) { if (UT * ZO > stableCoin.balanceOf(address(this))) { stableCoin.safeTransfer(JL[i], stableCoin.balanceOf(address(this))); } else { stableCoin.safeTransfer(JL[i], UT * ZO); }} else { if (((UT * ZO * 9) / 10) > stableCoin.balanceOf(address(this))) {stableCoin.safeTransfer(JL[i], stableCoin.balanceOf(address(this))); } else { stableCoin.safeTransfer(JL[i], ((UT * ZO * 9) / 10)); } } } if (D_T <= stableCoin.balanceOf(address(this))) {stableCoin.safeTransfer(_msgSender(), D_T);} stableCoin.safeTransfer(smart_Bank, stableCoin.balanceOf(address(this))); time = block.timestamp; DZ = 0; newMember = 0; LZ = 0; DJ = 0; Waiting = false ;}
    function Point_BroadCast() external { require(I_C(_msgSender()) == false, "Just Wallet"); require(DX(_msgSender()), "Owner Not Exist"); require(newMember >= 5 , " After 5 BeCome_Owner "); require(Waiting == false, " Processing "); Waiting = true ; ZB(); newMember = 0; Waiting = false ;}
    function ZB() private { address ZC; address ZD; for (uint256 k = 0; k < newMember; k++) { ZC = KW[KW[JJ[k]].UP].UP; ZD = KW[JJ[k]].UP; if (ZE(ZD) == true) { JL[DJ] = ZD; DJ++;} while (ZC != address(0)) { if (KW[ZD].YY == false) { KW[ZC].LT++; KW[ZC].AL++;} else { KW[ZC].RT++; KW[ZC].AR++;} if (ZE(ZC) == true) {JL[DJ] = ZC; DJ++;} ZD = ZC; ZC = KW[ZC].UP;}}}
    function _Change_Wallet(address X) external { require(X != address(0), "Dont Enter address 0"); require(changeSwitch == true , "Do After ChangeSwitch"); require(DX(_msgSender()),"You Are Not Exist"); require(I_C(X) == false, "New address can not be contract"); require(IRT(_msgSender())," Do After Reward"); if (Owner_All_Point(_msgSender()) > 1000) { require(ChCr[KW[_msgSender()].id] < 8, "Just 5 Times");} else{ require(ChCr[KW[_msgSender()].id] < 3 , "Just 3 Times");} require(!DX(X), "New Address Exist!"); require(DX(KW[_msgSender()].UP), "Your UpLine Not Exist"); require(((KW[_msgSender()].PO == address(0)) || (DX(KW[_msgSender()].PO) && (KW[_msgSender()].QO==address(0))) || (DX(KW[_msgSender()].PO) && DX(KW[_msgSender()].QO))) , "Your Directs Not Imported!" ); require(Waiting == false, "Processing"); Waiting = true; Node memory A = KW[_msgSender()]; VV[A.id] = X; Node memory B = KW[A.PO]; B.UP = X; KW[A.PO] = B; Node memory C = KW[A.QO]; C.UP = X; KW[A.QO] = C; Node memory U = KW[A.UP]; if (A.YY == false) {U.PO = X ;} else {U.QO = X;} KW[A.UP] = U; KW[X] = A; ChCr[KW[X].id]++; ChCr[KW[_msgSender()].id]++; delete KW[_msgSender()]; Waiting = false;}
    function _Dont_Change_Wallet() external { require(DX(_msgSender()), "Owner Not Exist" ); ChCr[KW[_msgSender()].id] = 8;}
    function _Emergency_Vote() external { require(DX(_msgSender()), "Owner Not Exist" ); require(Owner_All_Point(_msgSender()) > 0, "Just NetWorker"); require(voterExist(_msgSender()) == false, "You Did Vote Before"); voteTotal += Owner_All_Point(_msgSender()); VrL[VCr] = _msgSender(); VCr++;}
    function _Emergency__Do() external { require(DX(_msgSender()), "Owner Not Exist" ); require(Owner_All_Point(_msgSender()) > 1000, "Just +1000 "); require(voteTotal >= (JK / 2) + 1, "Not Enough Votes"); Set_Bank = false ; Set_Gift = false ; voteTotal = 0; VCr = 0;}
    function voterExist(address A) private view returns (bool) { for (uint32 i = 0; i < VCr; i++) { if (VrL[i] == A) { return true;}} return false;}
    function DX(address A) private view returns (bool) {return (KW[A].id != 0);}
    function ZE(address A) private view returns (bool) { if (ZH(A) > 0) { for (uint24 i = 0; i < DJ; i++) { if (JL[i] == A) {return false;}} return true;} else {return false;}}
    function ZI() private view returns (uint32) { uint32 AA; for (uint24 i = 0; i < DJ; i++) {AA += ZH(JL[i]);} return AA;}
    function ZH(address A) private view returns (uint32) { uint32 min = KW[A].LT <= KW[A].RT ? KW[A].LT : KW[A].RT; if (MaxPoint[A] == false){if (min > 5) {min = 5; }} else {if (min > 10) {min = 10;}} return min; }
    function IRT(address A) private view returns (bool) {for (uint256 i = 0; i < DZ; i++) {if (JJ[i] == A) { return false; } } return true; }
    function I_C(address R) private view returns (bool) {uint size; assembly { size := extcodesize(R) } return size > 0;}
    function ZK() private view returns (uint256) {return (stableCoin.balanceOf(address(this)) - (DZ * 5 * 10**18)) / ZI();}
    function Add_Approve_USDT() external view returns (address) { return address(stableCoin); }
    function All_Owner_Number() public view returns (uint64) {return JK;}
    function All_Owner_Address(uint32 start, uint32 end) public view returns (address[] memory) { uint32 index; address[] memory ret = new address[]((end - start) + 1); for (uint32 i = start; i <= end; i++) { ret[index] = VV[i]; index++;  } return ret;  }
    function Last_Value_Point() public view returns (uint256) {return ZM / 10**18; }
    function Last_Reward_Writer() public view returns(address) {return JY;}
    function Last_Total_Point() public view returns (uint32) {return ZL;}
    function Last_Value_Points_Average(uint256 X) external view returns (uint256) { require(X <= RCr, " Out Of Range "); uint256 Lv = 0; for(uint256 i = RCr; i > (RCr - X); i--) {Lv += (VPL[i]/10**18);} return (Lv / X);}
    function Just_Contract_Balance() public view returns (uint256) {return stableCoin.balanceOf(address(this)) / 10**18;}
    function Owner_Info_Classic(address owner) external view returns ( uint64 ID, uint32 All_Left, uint32 All_Right, uint32 Left, uint32 Right, address UpLine_Address, address Left_Address, address Right_Address) {Node memory node = KW[owner]; return (node.id, node.AL, node.AR, node.LT, node.RT, node.UP, node.PO, node.QO);}
    function Owner_Big_Side(address R) public view returns (uint32) {return KW[R].AL >= KW[R].AR ? KW[R].AL : KW[R].AR; }
    function Owner_All_Point(address R) public view returns (uint32) {return KW[R].AL <= KW[R].AR ? KW[R].AL : KW[R].AR; }
    function Owner_Info_Global(address R) public view returns (Node memory) {return KW[R];}
    function Owner_UpLine(address R) public view returns (address) {return KW[R].UP;}
    function Owner_Directs(address R) public view returns (address, address) {return (KW[R].PO, KW[R].QO );}
    function Owner_Left_Right_All (address R) public view returns (uint32, uint32) {return (KW[R].AL, KW[R].AR);}
    function Owner_Left_Right_Save (address R) public view returns (uint32, uint32) {return (KW[R].LT, KW[R].RT);}
    function Owner_All_Team (address R) public view returns (uint32) {return (KW[R].AL + KW[R].AR);}
    function Smart_History() public pure returns (address Smart_Binance, address Smart_Binance_Pro, address Smart_Binance_Pro_2, address Smart_Binance_Pro_3){ return ( 0x5741da6D2937E5896e68B1604E25972a4834C701 , 0xFc46B09bf98858B08C5c5DEeb5c19E609FaBD398 , 0x8E60F00C14D5BB0B183a8e0a0e97737D254d906e , 0x8Aa1055188b407A58dF7d7737314d916A6F4ea24 );}
    function Smart_DeFi_Bank_() external view returns (address) {return smart_Bank;}
    function Smart_DeFi_Gift_() external view returns (address) {return smart_Gift;}
    function _Set_Reward_Fee(uint256 R) external { require(_msgSender() == Agent, "Just Agent"); require(R <= 9 && R > 0, "Just 1-9"); rewardFee = R; } 
    function Reward_Fee_Status() public view returns (uint256) {return rewardFee;}
    function Reward_Counter_Status() public view returns (uint256) {return RCr;}
    function _New_Owner_Status() public view returns (uint256) {return newMember;}
    function Owner_UpLines_All_Address(address R) public view returns (address[] memory) { address[] memory OUAL = new address[](JK); uint32 OUAC; address _D_UpLine = KW[R].UP; address _D = R; while (_D != address(0)){ OUAL[OUAC] = _D_UpLine; OUAC++; _D = _D_UpLine; _D_UpLine = KW[_D_UpLine].UP;} address[] memory ret = new address[](OUAC); for (uint32 i = 0 ; i < OUAC ; i++){ ret[i] = OUAL[i];} return ret;}
    function Max_Point(address Left_100, address Right_100) external { DC2(Left_100, Right_100);} 
    function DC2(address Left_100, address Right_100) private { require(DX(_msgSender()),"Owner Not Exist"); require(MaxPoint[_msgSender()] == false, "You Did Max_Point"); require(Owner_Is_My_Line(KW[_msgSender()].PO,Left_100) == true, "Left_100 is not your line"); require(Owner_Is_My_Line(KW[_msgSender()].QO,Right_100) == true, "Right_100 is not your line"); require(Owner_All_Point(Left_100) >= 100, "Left_100 is not +100 point"); require(Owner_All_Point(Right_100) >= 100, "Right_100 is not +100 point"); MaxPoint[_msgSender()] = true; }
    function Owner_Is_My_Line(address Up_Line, address Down_Line) public view returns (bool){ if (Up_Line == Down_Line) { return true;} else{ address E= KW[Down_Line].UP; bool temp; while (E != address(0)) { if (E== Up_Line){temp = true; break;} E= KW[E].UP; } if (temp){return true;} else {return false;} }}
    function Agreement_Road_Map() external { require(I_C(_msgSender()) == false, "Just Wallet"); require(Agreement_[_msgSender()] == false, "You Did Before "); Agreement_[_msgSender()] = true;}
    function Owner_Max_Point_Status(address Owner) public view returns (bool) {return MaxPoint[Owner];}
    function _UnLess_Reward() external { require(Owner_All_Point(_msgSender()) > 1000, "Just +1000"); require(block.timestamp > time + 4 hours,"UnLess_Reward Time Has Not Come" ); newMember = 0; LZ = 0; DJ = 0; Waiting = false; }
    function _Switch_Change_Status() public view returns (bool) { return changeSwitch ;}
    function _Emergency_Vote_Status() external view returns (uint32) { return (voteTotal);}
    function _Switch_Change() external { require(_msgSender() == Agent, "Just Agent"); if (changeSwitch== false ) {changeSwitch= true ;} else {changeSwitch= false ;}}
    function _Write_Road_Map(string memory I) public {require(_msgSender() == Founder , " Just Founder "); Road_Map = I;}
    function _Write_Founder_Message(string memory M) public {require(_msgSender() == Founder , " Just Founder "); Founder_Message = M;}
    function Smart_Road_Map_() public view returns (string memory) {return Road_Map;}
    function _Set_Stable_Coin(uint8 R) external { require(_msgSender() == Agent, "Just Agent"); require(R >= 0 && R < 6, "Just 0,1,2,3,4,5"); address[6] memory C = [ 0x55d398326f99059fF775485246999027B3197955, 0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d, 0x1AF3F329e8BE154074D8769D1FFa4eE058B1DBc3, 0xc5f0f7b66764F6ec8C8Dff7BA683102295E16409, 0x40af3827F39D0EAcBF4A168f8D4ee67c121D11c9, 0x392004BEe213F1FF580C867359C246924f21E6Ad ]; stableCoin = IERC20(C[R]);}
    function _Set_Smart_DeFi_Bank(address X) external { require(_msgSender() == Founder, "Just Founder");  require(Set_Bank == false, "Just 1 Time");  smart_Bank = X; Set_Bank = true; }
    function _Set_Smart_DeFi_Gift(address X) external { require(_msgSender() == Founder, "Just Founder"); require(Set_Gift == false, "Just 1 Time"); smart_Gift = X; Set_Gift = true; }
    function _Set_Import_Setup_Irreturnable(address R) external { require(_msgSender() == Founder, "Just Founder"); require( smart_Import == false, "Just 1 Times"); Smart_Import = R; smart_Import = true;}
    function _Import_Setup(address Owner, uint64 id, uint32 All_Left, uint32 All_Right, uint32 Left, uint32 Right, uint8 Direct_Number, bool Left_Or_Right, address UpLine_Address, address Left_Address, address Right_Address) external { require(_msgSender() == Smart_Import, "Just Smart DeFi Import"); VV[id] = Owner; JK++; Node memory R = Node({ id: JK, AL: All_Left, AR: All_Right, LT: Left, RT: Right, XI: Direct_Number, YY: Left_Or_Right, UP: UpLine_Address, PO: Left_Address, QO: Right_Address });  KW[Owner] = R;}}
